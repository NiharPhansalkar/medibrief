from pyspark.ml import PipelineModel
from sparknlp.pretrained import PretrainedPipeline

import sparknlp_jsl.internal as _internal
import json

class PipelineTracer:
    """
    PipelineTracer is a class that allows to trace the stages of a pipeline and get information about them.
    The `PipelineTracer` class provides functionality for tracing and retrieving information about the various stages of a pipeline.
    It can be used to obtain detailed insights into the entities, assertions, and relationships utilized within the pipeline.
    Compatibility with both `PipelineModel` and `PretrainedPipeline`.
    It can be used with a PipelineModel or a PretrainedPipeline.
    Additionally, it can be used to create a parser dictionary that can be used to create a PipelineOutputParser.
    """

    def __init__(self, pipeline):
        """
        :param pipeline: A PipelineModel or a PretrainedPipeline
        """
        if isinstance(pipeline, PipelineModel):
            self.pipeline_model = pipeline
            self._PipelineTracer = _internal._PipelineTracer(pipeline).apply()
        elif isinstance(pipeline, PretrainedPipeline):
            pipeline_model_temp = pipeline.model
            self.pipeline_model = pipeline_model_temp
            self._PipelineTracer = _internal._PipelineTracer(pipeline_model_temp).apply()
        else:
            raise ValueError("PipelineTracer only accepts PipelineModel or PretrainedPipeline")
        
    def printPipelineSchema(self):
        """
        Prints the schema of the pipeline.
        """
        print(self._PipelineTracer.createPipelineSchema())

    def createParserDictionary(self):
        """Returns a parser dictionary that can be used to create a PipelineOutputParser.
        Notes:
        ------
        This method tries to return a compatible PipelineOutputParser.
        You should make sure that the parser dictionary is compatible with the PipelineOutputParser that you are using.
        """
        parser_dict = self._PipelineTracer.createParserDictionary()
        return dict(json.loads(parser_dict))

    def getPossibleAssertions(self):
        """Returns a list of possible assertions that the pipeline can include."""
        return list(self._PipelineTracer.getPossibleAssertions())

    def getPossibleRelations(self):
        """Returns a list of possible relations that the pipeline can include."""
        return list(self._PipelineTracer.getPossibleRelations())

    def getPossibleEntities(self):
        """Returns a list of possible entities that the pipeline can include."""
        return list(self._PipelineTracer.getPossibleEntities())

    def getPipelineStages(self):
        """Returns a list of PipelineStage objects that represent the stages of the pipeline."""
        return self._pipelineStagesFromJava(self._PipelineTracer.getJavaPipelineStages())

    def _pipelineStagesFromJava(self, pipeline_stages):
        stages = []
        for stage in pipeline_stages:
            stages.append(PipelineStage(self.pipeline_model.stages[stage.index()],
                                        stage.uid(),
                                        stage.name(),
                                        stage.index(),
                                        StageField(stage.inputCol().name(), stage.inputCol().value(), stage.inputCol().fieldType()),
                                        StageField(stage.outputCol().name(), stage.outputCol().value(), stage.outputCol().fieldType()),
                                        StageField(stage.inputAnnotatorType().name(), stage.inputAnnotatorType().value(), stage.inputAnnotatorType().fieldType()),
                                        StageField(stage.outputAnnotatorType().name(), stage.outputAnnotatorType().value(), stage.outputAnnotatorType().fieldType())
                                        )
                        )
        return stages

    @staticmethod
    def getParserDictDirectly(model: str, language: str = "en", source: str = "clinical/models"):
        """Returns a parser dictionary that can be used to create a PipelineOutputParser.
        This method is used to get the parser dictionary directly without creating a PipelineTracer object.
        This method throws an IllegalArgumentException if the model is not available.
        You can use the listAvailableModels method to get a list of available models.

        Parameters:
        ----------
        model: str
            The name of the model.
        language: str
            The language of the model. Default is "en".
        source: str
            The source of the model. Default is "clinical/models".

        Returns:
        --------
        dict
            A dictionary that can be used to create a PipelineOutputParser.

        Throws:
        -------
        IllegalArgumentException
            If the model is not available.
        """
        parser_dict_str = _internal._GetParserDictDirectly(model, language, source).apply()
        return dict(json.loads(parser_dict_str))

    @staticmethod
    def listAvailableModels(language: str = "en", source: str = "clinical/models"):
        """
        Returns a list of available models for a given language and source.

        Parameters:
        -----------
        language: str
            The language of the models. Default is "en".
        source: str
            The source of the models. Default is "clinical/models".
        """
        return list(_internal._ListAvailableModels(language, source).apply())

    @staticmethod
    def showAvailableModels(language: str = "en", source: str = "clinical/models"):
        """
        Prints a list of available models for a given language and source.

        Parameters:
        -----------
        language: str
            The language of the models. Default is "en".
        source: str
            The source of the models. Default is "clinical/models".
        """
        available_models = PipelineTracer.listAvailableModels(language, source)
        for model in available_models:
            print(model)



class PipelineStage:
    """
    Represents a stage of a pipeline. 
    It contains information about the stage such as the uid, name, index, inputCol, outputCol, inputAnnotatorType and outputAnnotatorType.
    """
    def __init__(self, stage, uid, name, index, inputCol, outputCol, inputAnnotatorType, outputAnnotatorType):
        self.stage = stage
        self.uid = uid
        self.name = name
        self.index = index
        self.inputCol = inputCol
        self.outputCol = outputCol
        self.inputAnnotatorType = inputAnnotatorType
        self.outputAnnotatorType = outputAnnotatorType

    def __str__(self):
        return "PipelineStage(%s, %s, %i, %s, %s, %s, %s)" % (
            self.uid,
            self.name,
            self.index,
            self.inputCol,
            self.outputCol,
            self.inputAnnotatorType,
            self.outputAnnotatorType
        )

    def __repr__(self):
        return self.__str__()
    
    def __dict__(self):
        return {
            "uid": self.uid,
            "name": self.name,
            "index": self.index,
            "inputCol": self.inputCol,
            "outputCol": self.outputCol,
            "inputAnnotatorType": self.inputAnnotatorType,
            "outputAnnotatorType": self.outputAnnotatorType
        }
    
    def __dict__dict__(self):
        return {
            "uid": self.uid,
            "name": self.name,
            "index": self.index,
            "inputCol": self.inputCol.__dict__(),
            "outputCol": self.outputCol.__dict__(),
            "inputAnnotatorType": self.inputAnnotatorType.__dict__(),
            "outputAnnotatorType": self.outputAnnotatorType.__dict__()
        }


class StageField:
    """
    Represents a field of a stage. A stage field contains information about the name, value and fieldType of the field.
    """
    def __init__(self, name, value, fieldType):
        self.name = name
        self.value = value
        self.fieldType = fieldType

    def __str__(self):
        return "StageField(%s, %s, %s)" % (
            self.name,
            self.value if not self.fieldType == "array" else f"[{self.value}]",
            self.fieldType
        )

    def __repr__(self):
        return self.__str__()
    
    def __dict__(self):
        return {
            "name": self.name,
            "value": self.value if not self.fieldType == "array" else f"[{self.value}]",
            "fieldType": self.fieldType
        }
